/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All data
 * is considered private and can only be accessed by the authenticated user who
 * owns it. There is no public or shared data.
 *
 * Data Structure: The data is organized hierarchically, with all user-specific
 * information nested under the `/users/{userId}` path. This structure includes
 * user profiles, their vehicles, and detailed logs for each vehicle, such as
 * fuel fill-ups and maintenance alerts. This path-based nesting is the primary
 * mechanism for enforcing security.
 *
 * Key Security Decisions:
 * - Default Deny: All access is denied by default. Rules explicitly grant permissions.
 * - Authentication Required: No anonymous access is permitted for any operation.
 * - No User Enumeration: Listing the top-level `/users` collection is disallowed
 *   to protect user privacy.
 * - Path-Based Ownership: Authorization is determined by matching the `{userId}`
 *   wildcard in the document path with the authenticated user's UID. This avoids
 *   slow and costly `get()` calls to other documents for authorization checks.
 *
 * Denormalization for Authorization: The hierarchical structure itself is a form
 * of denormalization for authorization. By placing a user's vehicles under their
 * unique path (`/users/{userId}/vehicles/{vehicleId}`), the ownership is implicit
 * in the path, making security rules simple, fast, and secure. Furthermore, on
 * document creation, we enforce that internal ID fields (like `User.id` or
 * `Vehicle.userId`) match the IDs in the path to ensure data integrity.
 *
 * Structural Segregation: The entire data model uses structural segregation.
 * All data for a single user is contained within their own document tree, ensuring
 * that all documents within a given subcollection share the same security context
 * (owner-only access). This prevents security bugs and improves query performance.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions to improve readability and reuse
    function isSignedIn() {
      return request.auth != null;
    }

    // Checks if the requesting user is the owner of the document based on the path.
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // For update/delete, ensures the user is the owner AND the document already exists.
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // Validates that the User document being created has an 'id' matching the path.
    function hasValidUserData(userId) {
      return request.resource.data.id == userId;
    }

    // Ensures the User 'id' cannot be changed after creation.
    function isUserDataImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    // Validates that the Vehicle document being created has IDs matching the path.
    function hasValidVehicleData(userId, vehicleId) {
      return request.resource.data.userId == userId && request.resource.data.id == vehicleId;
    }

    // Ensures the Vehicle's ownership and ID fields cannot be changed.
    function isVehicleDataImmutable() {
      return request.resource.data.userId == resource.data.userId && request.resource.data.id == resource.data.id;
    }

    // Validates that the FuelLog document being created has IDs matching the path.
    function hasValidFuelLogData(vehicleId, fuelLogId) {
      return request.resource.data.vehicleId == vehicleId && request.resource.data.id == fuelLogId;
    }

    // Ensures the FuelLog's parent vehicle and ID fields cannot be changed.
    function isFuelLogDataImmutable() {
      return request.resource.data.vehicleId == resource.data.vehicleId && request.resource.data.id == resource.data.id;
    }

    // Validates that the MaintenanceAlert document being created has IDs matching the path.
    function hasValidMaintenanceAlertData(vehicleId, maintenanceAlertId) {
      return request.resource.data.vehicleId == vehicleId && request.resource.data.id == maintenanceAlertId;
    }

    // Ensures the MaintenanceAlert's parent vehicle and ID fields cannot be changed.
    function isMaintenanceAlertDataImmutable() {
      return request.resource.data.vehicleId == resource.data.vehicleId && request.resource.data.id == resource.data.id;
    }

    /**
     * @description Controls access to a user's own profile document.
     * @path /users/{userId}
     * @allow A signed-in user (auth.uid=`user123`) creating their own user document (at `/users/user123`). (create)
     * @deny An anonymous user trying to read a user profile. (get)
     * @deny A signed-in user (auth.uid=`user456`) trying to delete another user's profile (`/users/user123`). (delete)
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && hasValidUserData(userId);
      allow update: if isExistingOwner(userId) && isUserDataImmutable();
      allow delete: if isExistingOwner(userId);

      /**
       * @description Controls access to the collection of vehicles owned by a user.
       * @path /users/{userId}/vehicles/{vehicleId}
       * @allow A signed-in user (auth.uid=`user123`) listing their own vehicles. (list)
       * @allow A signed-in user (auth.uid=`user123`) creating a new vehicle under their own profile. (create)
       * @deny A signed-in user (auth.uid=`user456`) trying to read a vehicle owned by `user123`. (get)
       * @principle Enforces strict data ownership for a user's subcollections based on path.
       */
      match /vehicles/{vehicleId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && hasValidVehicleData(userId, vehicleId);
        allow update: if isExistingOwner(userId) && isVehicleDataImmutable();
        allow delete: if isExistingOwner(userId);

        /**
         * @description Controls access to fuel logs for a specific vehicle.
         * @path /users/{userId}/vehicles/{vehicleId}/fuelLogs/{fuelLogId}
         * @allow A signed-in user (auth.uid=`user123`) reading a fuel log for one of their vehicles. (get)
         * @allow A signed-in user (auth.uid=`user123`) creating a fuel log for one of their vehicles. (create)
         * @deny An anonymous user trying to list fuel logs. (list)
         * @deny A signed-in user (auth.uid=`user456`) trying to delete a fuel log for a vehicle owned by `user123`. (delete)
         * @principle Inherits ownership from the parent path, ensuring only the vehicle owner can manage logs.
         */
        match /fuelLogs/{fuelLogId} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isOwner(userId) && hasValidFuelLogData(vehicleId, fuelLogId);
          allow update: if isExistingOwner(userId) && isFuelLogDataImmutable();
          allow delete: if isExistingOwner(userId);
        }

        /**
         * @description Controls access to maintenance alerts for a specific vehicle.
         * @path /users/{userId}/vehicles/{vehicleId}/maintenanceAlerts/{maintenanceAlertId}
         * @allow A signed-in user (auth.uid=`user123`) listing maintenance alerts for their vehicle. (list)
         * @allow A signed-in user (auth.uid=`user123`) creating a new maintenance alert for their vehicle. (create)
         * @deny A signed-in user (auth.uid=`user456`) reading an alert for another user's vehicle. (get)
         * @principle Inherits ownership from the parent path, ensuring only the vehicle owner can manage alerts.
         */
        match /maintenanceAlerts/{maintenanceAlertId} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isOwner(userId) && hasValidMaintenanceAlertData(vehicleId, maintenanceAlertId);
          allow update: if isExistingOwner(userId) && isMaintenanceAlertDataImmutable();
          allow delete: if isExistingOwner(userId);
        }
      }
    }
  }
}